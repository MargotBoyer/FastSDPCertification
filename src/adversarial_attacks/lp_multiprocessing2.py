import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
from torch.autograd import grad
from typing import List, Optional
import multiprocessing as mp
import queue
import time

from solve import ClassicLP
from bounds.bounds import compute_bounds_data
from tools import round_list_depth_2, round_list_depth_3


class LPAttack2:
    """
    Impléementation of the Linear Programming based attack.

    Args:
        model: the model to attack
        eps: pertubation ball radius
        random_start: if True, starts with a random perturbation, else starts with zero perturbationœ
        targeted: if True, performs a targeted attack (attacks a specific class), else performs an untargeted attack
        norm: Types of norm ('inf', '2', '1')
    """

    def __init__(
        self,
        model,
        num_classes,
        eps=0.3,
        targeted=False,
        norm="inf",
        compute_bounds_method="alpha-CROWN",
    ):
        self.model = model
        self.num_classes = num_classes
        self.eps = eps
        print("epsilon in LPAttack : ", self.eps)
        self.targeted = targeted
        self.norm = norm
        self.compute_bounds_method = compute_bounds_method

    def forward(self, image, ytrue, ytarget) -> List:
        """
        Generate adversarial images using the Linear Program Based attack.

        Args:
            images: Batch of images (torch.Tensor)
            labels: True labels of the images (torch.Tensor)
            target_labels: Target labels for targeted attacks (torch.Tensor, optional)

        Returns:
            adversarial_images: Adversarial images generated by the attack (torch.Tensor)
        """

        loss_pertubation = 0
        # print('W : ', round_list_depth_3(self.model.W,2))
        # print('b : ', round_list_depth_2(self.model.b,2))

        L, U = compute_bounds_data(
            self.model,
            image,
            self.eps,
            self.model.n,
            self.model.K,
            method=self.compute_bounds_method,
        )
        print(f"len U : {[len(u) for u in U]}")
        print(f"len L : {[len(l) for l in L]}")
        print("Min U : ", [min(u) for u in U], "   max U : ", [max(u) for u in U])
        print("Min L : ", [min(l) for l in L], "   max L : ", [max(l) for l in L])
        lp = ClassicLP(
            network=self.model,
            x=image,
            ytrue=ytrue,
            ytarget=ytarget,
            epsilon=self.eps,
            L=L,
            U=U,
        )
        lp.solve()
        loss_pertubation += lp.get_optimal_value()

        self.adv_images.append(lp.get_adversarial_attack().cpu().numpy())
        self.loss_pertubation += loss_pertubation

    def __call__(self, images, labels):
        """
        Call the forward method to generate adversarial images.

        Args:
            images: Batch of images (torch.Tensor)
            labels: True labels of the images (torch.Tensor)

        Returns:
            adversarial_images: Adversarial images generated by the attack (torch.Tensor)
        """
        images = images.clone().detach()
        labels = labels.clone().detach()

        list_tasks = []

        for ind in range(len(images)):
            for j in range(self.num_classes):
                if labels[ind] == j:
                    continue
                image = images[ind].cpu().numpy()
                ytrue = labels[ind].item()
                ytarget = j
                list_tasks.append((image, ytrue, ytarget))

        self.adv_images = []
        self.loss_pertubation = 0

        with mp.Pool() as pool:
            print("Number of cpu : ", mp.cpu_count())
            pool.map(self.forward, list_tasks)

        adv_images = torch.tensor(
            self.adv_images, dtype=images.dtype, device=images.device
        )
        print(f"Adversarial images shape: {adv_images.shape}")
        return self.loss_pertubation, adv_images
