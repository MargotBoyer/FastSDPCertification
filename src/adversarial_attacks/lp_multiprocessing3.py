import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
from torch.autograd import grad
from typing import List, Optional
import multiprocessing as mp
import queue
import time

from solve import ClassicLP
from networks import ReLUNN
from bounds.bounds import compute_bounds_data
from tools import round_list_depth_2, round_list_depth_3
import sys


device = torch.device("cuda" if torch.cuda.is_available() else "cpu")


def process_single_attack(args):
    """
    Fonction globale pour traiter une seule attaque.
    Cette fonction sera utilisée par multiprocessing.
    """
    K, n, W, b, image, ytrue, ytarget, eps, L, U, name_run = args
    sys.stdout.flush()

    print("Processing run :", name_run)
    model = ReLUNN(K, n, W=W, b=b, dropout_prob=0.0, name="ReLUNN").cpu()
    try:
        print("Entering try loop in process_single_attack", flush=True)
        lp = ClassicLP(
            network=model,
            x=image,
            ytrue=ytrue,
            ytarget=ytarget,
            epsilon=eps,
            L=L,
            U=U,
        )
        print(f"Created LP instance for run: {name_run}", flush=True)
        lp.solve()
        print("LP solve completedé, flush", flush=True)

        loss_pertubation = lp.get_optimal_value()
        adv_image = lp.get_adversarial_attack().cpu().numpy()
        print(f"Process {name_run} completed with loss: {loss_pertubation}")
        return loss_pertubation, adv_image
    except Exception as e:
        print(f"Erreur dans Process_single_attack: {e}")
        return 0, image


def create_model_from_config(config):
    """
    Fonction pour recréer le modèle à partir de sa configuration.
    Vous devrez adapter cette fonction selon votre architecture.
    """
    # Exemple - adaptez selon votre modèle
    # return YourModelClass(**config)
    pass


# class LPAttack2:
#     """
#     Implémentation of the Linear Programming based attack.

#     Args:
#         model: the model to attack
#         eps: pertubation ball radius
#         random_start: if True, starts with a random perturbation, else starts with zero perturbation
#         targeted: if True, performs a targeted attack (attacks a specific class), else performs an untargeted attack
#         norm: Types of norm ('inf', '2', '1')
#     """

#     def __init__(
#         self,
#         model,
#         num_classes,
#         eps=0.3,
#         targeted=False,
#         norm="inf",
#         compute_bounds_method="alpha-CROWN",
#     ):
#         self.model = model
#         self.num_classes = num_classes
#         self.eps = eps
#         print("epsilon in LPAttack : ", self.eps)
#         self.targeted = targeted
#         self.norm = norm
#         self.compute_bounds_method = compute_bounds_method

#     def forward_single(self, image, ytrue, ytarget):
#         """
#         Generate adversarial image for a single target using the Linear Program Based attack.
#         Version séquentielle pour éviter les problèmes de multiprocessing.
#         """
#         try:
#             L, U = compute_bounds_data(
#                 self.model,
#                 image,
#                 self.eps,
#                 self.model.n,
#                 self.model.K,
#                 method=self.compute_bounds_method,
#             )

#             lp = ClassicLP(
#                 network=self.model,
#                 x=image,
#                 ytrue=ytrue,
#                 ytarget=ytarget,
#                 epsilon=self.eps,
#                 L=L,
#                 U=U,
#             )
#             lp.solve()

#             loss_pertubation = lp.get_optimal_value()
#             adv_image = lp.get_adversarial_attack().cpu().numpy()

#             return loss_pertubation, adv_image
#         except Exception as e:
#             print(f"Erreur dans forward_single: {e}")
#             return 0, image.cpu().numpy()

#     def __call__(self, images, labels):
#         """
#         Call the forward method to generate adversarial images.

#         Args:
#             images: Batch of images (torch.Tensor)
#             labels: True labels of the images (torch.Tensor)

#         Returns:
#             loss_pertubation: Total perturbation loss
#             adversarial_images: Adversarial images generated by the attack (torch.Tensor)
#         """
#         images = images.clone().detach()
#         labels = labels.clone().detach()

#         # Préparer les tâches
#         list_tasks = []
#         for ind in range(len(images)):
#             for j in range(self.num_classes):
#                 if labels[ind] == j:
#                     continue
#                 image = images[ind]
#                 ytrue = labels[ind].item()
#                 ytarget = j
#                 list_tasks.append((image, ytrue, ytarget))

#         # Traitement séquentiel (plus fiable)
#         adv_images = []
#         total_loss_pertubation = 0

#         print(f"Traitement de {len(list_tasks)} tâches d'attaque...")

#         for i, (image, ytrue, ytarget) in enumerate(list_tasks):
#             print(
#                 f"Traitement tâche {i+1}/{len(list_tasks)}: ytrue={ytrue}, ytarget={ytarget}"
#             )

#             loss_pertubation, adv_image = self.forward_single(image, ytrue, ytarget)

#             total_loss_pertubation += loss_pertubation
#             adv_images.append(adv_image)

#         # Convertir en tensor
#         adv_images = torch.tensor(adv_images, dtype=images.dtype, device=images.device)
#         print(f"Adversarial images shape: {adv_images.shape}")

#         return total_loss_pertubation, adv_images


class LPAttack3Parallel:
    """
    Version parallèle alternative utilisant torch.multiprocessing
    """

    def __init__(
        self,
        model,
        num_classes,
        eps=0.3,
        targeted=False,
        norm="inf",
        compute_bounds_method="alpha-CROWN",
    ):
        self.model = model
        self.num_classes = num_classes
        self.eps = eps
        self.targeted = targeted
        self.norm = norm
        self.compute_bounds_method = compute_bounds_method

    def __call__(self, images, labels, K, n, W, b):
        """
        Version utilisant torch.multiprocessing pour éviter les problèmes de sérialisation
        """
        import torch.multiprocessing as torch_mp

        images = images.clone().detach()
        labels = labels.clone().detach()

        list_tasks = []

        print("Process : creating tasks and computing bounds...")
        model = ReLUNN(K, n, W=W, b=b, dropout_prob=0.0, name="ReLUNN").to(device)

        for ind in range(len(images)):
            print(f"        Processing image {ind + 1}/{len(images)}")
            L, U = compute_bounds_data(
                model,
                images[ind].to(device),
                self.eps,
                model.n,
                model.K,
                method=self.compute_bounds_method,
            )
            image = images[ind].flatten().cpu().numpy()

            ytrue = labels[ind].item()
            print("        Image shape: ", image.shape)

            for j in range(self.num_classes):
                if labels[ind] == j:
                    continue

                ytarget = j

                args = (
                    K,
                    n,
                    W,
                    b,
                    image,
                    ytrue,
                    ytarget,
                    self.eps,
                    L,
                    U,
                    "Image_{}_Target_{}".format(ind, j),
                )
                list_tasks.append(args)

        print(f"Total tasks created: {len(list_tasks)}")
        print("Starting parallel Processing...")
        num_workers = 2
        # Traitement parallèle
        with mp.Pool(2) as pool:
            print("Pool started with 2 workers")
            results = pool.map(process_single_attack, list_tasks)

        # Traiter les résultats
        total_loss_pertubation = 0
        adv_images = []

        for loss_pertubation, adv_image in results:
            total_loss_pertubation += loss_pertubation
            adv_images.append(adv_image)

        adv_images = torch.tensor(adv_images, dtype=images.dtype, device=images.device)

        return total_loss_pertubation, adv_images

    def get_model_config(self):
        """
        Extrait la configuration du modèle pour pouvoir le recréer.
        À adapter selon votre architecture de modèle.
        """
        # Exemple - adaptez selon votre modèle
        return {
            "n": self.model.n if hasattr(self.model, "n") else None,
            "K": self.model.K if hasattr(self.model, "K") else None,
            # Ajoutez d'autres paramètres nécessaires
        }
